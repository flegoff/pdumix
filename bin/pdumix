#!/usr/bin/ruby

# == Synopsis
#
#   Power on or off outlets on APC PDUs, using SNMP
#
#
# == Examples
#
#   Reboot a node :
#   $ pdumix --reboot -h chinqchint-1.lille.grid5000.fr
#
#   Power on a node :
#   $ pdumix --up -h chinqchint-1.lille.grid5000.fr
#
#   Power off a node :
#   $ pdumix --down -h chinqchint-1.lille.grid5000.fr
#
#   Manual way :
#   $ pdumix --reboot -o 1 -p apc01.lille.grid5000.fr -c 79priv4t3
#
#
# == Usage
#   $ pdumix [options]
#
#   For help use : pdumix -h
#
# 
# == Options
#
#   A mandatory
#   -n, --name        Set the hostname to be looked up in the configuration
#
#   OR the mandatory fields (IN FUTURE RELEASES)
#   -o, --outlet      Outlet number
#   -p, --pdu         PDU hostname
#   -c, --community   SNMP write community
#
#   Combined with one of the following
#   -r, --reboot      Sends the reboot command to the power outlet
#   -u, --up          Power on the outlet
#   -d, --down        Power down the outlet
#
#   -h, --help        Display help
#   -v, --verbose     Run verbosely
#
# 
# == Authors
#
#  - Florian Le Goff < Florian.Le_Goff > at inria.fr
# 
# 
# == License
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
# OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
# EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
# EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

#
# APC OIDs
#

$powerUnitState = '1.3.6.1.4.1.318.1.1.12.3.3.1.1.4'
$powerUnitName  = '1.3.6.1.4.1.318.1.1.12.3.4.1.1.2'
$powerState = { :on => 1, :off => 2, :reboot => 3 }

# ---

require 'optparse'
require 'yaml'
require 'snmp'
include SNMP

# ---
# parse_options
# : parse the command line options
# => options : an empty hash table
# returns: nothing

def parse_options(options)

  opts = OptionParser.new
  opts.banner = "Usage: #{$0} <-r|-u|-d> -n <hostname>"
    
  opts.on("-n", "--name NODE", "Set the hostname to be looked up in the configuration") do |n|
    options[:node] = n;
  end

  opts.on("-r", "--reboot", "Sends a reboot command to the power outlet") do |r|
    options[:action] = $powerState[:reboot]
  end

  opts.on("-u", "--up", "Power on the outlet") do |r|
    options[:action] = $powerState[:on]
  end

  opts.on("-d", "--down", "Power down the outlet") do |r|
    options[:action] = $powerState[:off]
  end

  opts.on("-v", "--verbose", "Run verbosely") do |v|
    options[:verbose] = true
  end
        
  opts.on_tail("-h", "--help", "Show this message") do
    puts opts
    exit
  end
  
  opts.parse!
  
  if not options[:node]
    puts opts
    exit
  end
   
end


# ---
# fetch_file
# : loads the configuration file
# => file: file name
# returns : a hash table containing the configuration

def fetch_file(file)
  return YAML.load_file(file)
end


# ---
# fetch_node
# : loads a node from the configuration
# => file: configuration object from which the node should be loaded
# => name: node name
# => options: option hash table
# returns : a node hash

def fetch_node(file, options)
  name = options[:node]
  if options[:verbose]
    node = file[name]
    puts "[#{name}]"
    puts "  chassis=#{node['chassis']}"
    puts "  port=#{node['port']}"
    puts "  pdu=#{node['pdu']}"
    return node
  else
    return file[name]
  end
end


# ---
# rewrite_conf
# : rewrite the PDU's configuration with the chassis information
# => file: configuration object

def rewrite_conf(file)
  for i in file
    node = fetch_node(file, i[0])

    powerUnitState_OID = ObjectId.new("#{powerUnitState}.#{node['port']}")
    powerUnitName_OID = ObjectId.new("#{powerUnitName}.#{node['port']}")
    
    SNMP::Manager.open( :Host => node['pdu'],
                        :Community => 'private',
                        :WriteCommunity => 'private',
                        :Version => :SNMPv1) do |manager|
                          
      tportName = "chassis-#{node['chassis']}"
      portName = manager.get_value(powerUnitName_OID)
      portState = manager.get_value(powerUnitState_OID)
      
      print "  (R) name=#{portName}\n"
      print "  (R) state=#{portState}\n"
      
      print "  (W) name=#{tportName}\n"
      var = VarBind.new(powerUnitName_OID, SNMP::OctetString.new(tportName))
      manager.set(var)

    end
  end
end

# ---
# read_state
# : read the PDU's configuration
# => file: configuration object
# => node: node object
# => options: option hash table
 
def read_state(file,node,options)

  powerUnitState_OID = ObjectId.new("#{$powerUnitState}.#{node['port']}")
    
  SNMP::Manager.open( :Host => node['pdu'],
                      :Community => 'private',
                      :Version => :SNMPv1) do |manager|
    portState = manager.get_value(powerUnitState_OID)
    puts "current_state=#{portState}"
  end
  
end

# ---
# change_state
# : edit the PDU's configuration
# => file: configuration object
# => node: node object
# => options: option hash table
 
def change_state(file,node,options)

  powerUnitState_OID = ObjectId.new("#{$powerUnitState}.#{node['port']}")
    
  SNMP::Manager.open( :Host => node['pdu'],
                      :Community => 'private',
                      :WriteCommunity => 'private',
                      :Version => :SNMPv1) do |manager|
                          
    portState = manager.get_value(powerUnitState_OID)
    portNewState = options[:action]

    if options[:verbose]
      puts "  ? read   : state : #{portState}"
      puts "  = wanted : state : #{portNewState}"
    end

    if (portState != portNewState)
      puts "  ! write  : state : #{portNewState}" if options[:verbose]
      var = VarBind.new(powerUnitState_OID, SNMP::Integer.new(portNewState))
      manager.set(var)
    end
  end

end


#
# --- main
#

file = fetch_file('mapping_pdu.txt')

options = { }
parse_options(options)

if not (node = fetch_node(file, options))
  puts "#{$0}: error: node not found in configuration\n"
  exit
else
  if options[:action]
    change_state(file, node, options)
    read_state(file, node, options)
  else
    read_state(file, node, options)
  end
end

# eof
